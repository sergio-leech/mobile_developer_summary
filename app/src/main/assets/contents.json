{
  "contents" : [ {
    "contentId" : "1000",
    "description" : "Scoped functions are functions that execute a block of code within the context of an object. The context of the object can be referred to as “it” or “this” . There are five scoped functions in Kotlin: let, run, with, also and apply. ",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Kotlin%2Fusing-scoped-functions-summary.png?alt=media&token=5444c7a1-d2aa-405f-b846-5bc2e2c794cb",
    "menuId" : "01",
    "name" : "Scoped Functions"
  }, {
    "contentId" : "1001",
    "description" : "“let” operator provides an option to perform an operation on the current object and return any value based on the use case.  In Kotlin, if the last statement in a “let” block is a non-assignment statement, it is by default a return statement.’’Let” refers to the context of the object by using the “it” keyword and hence, this “it” can be renamed to a readable lambda parameter. “let” can also be used when we want to perform an operation on the result of a call chain.",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Kotlin%2Ffun_let.png?alt=media&token=b10dd2ca-b011-499f-bd82-570cd02c6432",
    "menuId" : "01",
    "name" : "Scoped Functions LET"
  }, {
    "contentId" : "1002",
    "description" : "The “run” operator is similar to the “let” operator in terms of accepting a return value that is different from the object on which the scope function is being applied to.\nSo if run is similar to let in terms of accepting any return value, what’s the difference? The difference is run refers to the context of the object as “this” and not “it”. That is the reason we did not use “${this.name}” as it would be redundant here since the block of code understands that “name” is used here concerning the Person object.\nOne point here is that since the context is referred to as “this”, it cannot be renamed to a readable lambda parameter. So depending on the use case and requirement we have to choose between the let and the run operator. The “run” operator also helps in easy null checks similar to the “let” operator\n",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Kotlin%2Ffun_run.png?alt=media&token=39368df0-6280-4737-97fa-10fc2850d8a6",
    "menuId" : "01",
    "name" : "Scoped Functions RUN"
  }, {
    "contentId" : "1003",
    "description" : "The “with” operator also refers to the context of the object as “this”, similar to how the “run” operator uses it. But performing a null check using a “with” operator is difficult and this is where we can replace it with “run” as follows:",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Kotlin%2Ffun_with.png?alt=media&token=2492a5bb-4620-4d86-926d-15b38b7b7b30",
    "menuId" : "01",
    "name" : "Scoped Functions WITH"
  }, {
    "contentId" : "1004",
    "description" : "Specifically for Android Development, \"apply\" can be useful in many cases. We have many scenarios where we should return an instance of Intent or an Alert Dialog etc., by adding specific attributes to them.",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Kotlin%2Ffun_apply.png?alt=media&token=a3de49bf-6344-4898-bfed-2267429ea926",
    "menuId" : "01",
    "name" : "Scoped Functions APPLY"
  }, {
    "contentId" : "6",
    "description" : "“also” does not accept a return statement",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Kotlin%2Ffun_also.png?alt=media&token=24690a6a-fa02-47ec-b2ce-9aa025f1f2cd",
    "menuId" : "01",
    "name" : "Scoped Functions ALSO"
  }, {
    "contentId" : "2000",
    "description" : "The Activity class is a crucial component of an Android app. Activity is a core Android class that is responsible for drawing an Android app UI and receiving input events. The Android system initiates code in an Activity instance by invoking specific callback methods that correspond to specific stages of its lifecycle. You implement an activity as a subclass of the Activity class. Most apps contain multiple screens, which means they comprise multiple activities. Typically, one activity in an app is specified as the main activity, which is the first screen to appear when the user launches the app. For your app to be able to use activities, you must declare the activities, and certain of their attributes, in the manifest. The only required attribute for this element is android:name, which specifies the class name of the activity.  Intent filters are a very powerful feature of the Android platform. They provide the ability to launch an activity based not only on an explicit request, but also an implicit one. For example, an explicit request might tell the system to “Start the Send Email activity in the Gmail app\". By contrast, an implicit request tells the system to “Start a Send Email screen in any activity that can do the job.\" When the system UI asks a user which app to use in performing a task, that’s an intent filter at work. You can take advantage of this feature by declaring an <intent-filter> attribute in the <activity> element. The definition of this element includes an <action> element and, optionally, a <category> element and/or a <data> element. If you intend for your app to be self-contained and not allow other apps to activate its activities, you don't need any other intent filters.",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Factivity.png?alt=media&token=5da0c069-80de-4dc7-8ca7-7b6db39bc954",
    "menuId" : "02",
    "name" : "Activities"
  }, {
    "contentId" : "2001",
    "description" : "The activity lifecycle is a set of states through which an activity migrates. The activity lifecycle begins when the activity is first created and ends when the activity is destroyed. As the user navigates between activities and inside and outside of your app, each activity moves between states in the activity lifecycle. Each state in the activity lifecycle has a corresponding callback method you can override in your Activity class. There are seven lifecycle methods : onCreate() - Called when the activity is starting. This is where most initialization should go: calling setContentView(int) to inflate the activity's UI, using findViewById(int) to programmatically interact with widgets in the UI, calling managedQuery() to retrieve cursors for data being displayed, etc.  onStart() - when the activity enters the Started state, the system invokes this callback. The onStart() call makes the activity visible to the user, as the app prepares for the activity to enter the foreground and become interactive. For example, this method is where the app initializes the code that maintains the UI. onResume- When the activity enters the Resumed state, it comes to the foreground, and then the system invokes the onResume() callback. This is the state in which the app interacts with the user. The app stays in this state until something happens to take focus away from the app. Such an event might be, for instance, receiving a phone call, the user’s navigating to another activity, or the device screen’s turning off. onPouse() - The system calls this method as the first indication that the user is leaving your activity (though it does not always mean the activity is being destroyed); it indicates that the activity is no longer in the foreground (though it may still be visible if the user is in multi-window mode). Use the onPause() method to pause or adjust operations that should not continue (or should continue in moderation) while the Activity is in the Paused state, and that you expect to resume shortly. onStop() - When your activity is no longer visible to the user, it has entered the Stopped state, and the system invokes the onStop() callback. This may occur, for example, when a newly launched activity covers the entire screen. The system may also call onStop() when the activity has finished running, and is about to be terminated. onDestroy() is called before the activity is destroyed. The system invokes this callback either because: the activity is finishing (due to the user completely dismissing the activity or due to finish() being called on the activity), or the system is temporarily destroying the activity due to a configuration change (such as device rotation or multi-window mode). A fragment also has a lifecycle. A fragment's lifecycle is similar to an activity's lifecycle onAttach()Called when the fragment has been associated with the activity (the Activity is passed in here).onCreateView() Called to create the view hierarchy associated with the fragment.onActivityCreated() Called when the activity's onCreate() method has returned.onDestroyView() Called when the view hierarchy associated with the fragment is being removed. onDetach() Called when the fragment is being disassociated from the activity.",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Flifecycle.png?alt=media&token=fcc1b471-d827-4ec6-b856-406f7aa458ab",
    "menuId" : "02",
    "name" : "Lifecycle"
  }, {
    "contentId" : "2002",
    "description" : "Use the Android lifecycle library to shift lifecycle control from the activity or fragment to the actual component that needs to be lifecycle-aware. Lifecycle owners are components that have (and thus \"own\") lifecycles, including Activity and Fragment. Lifecycle owners implement the LifecycleOwner interface. Lifecycle observers pay attention to the current lifecycle state and perform tasks when the lifecycle changes. Lifecycle observers implement the LifecycleObserver interface. Lifecycle objects contain the actual lifecycle states, and they trigger events when the lifecycle changes. To create a lifecycle-aware class: Implement the LifecycleObserver interface in classes that need to be lifecycle-aware. Initialize a lifecycle observer class with the lifecycle object from the activity or fragment. In the lifecycle observer class, annotate lifecycle-aware methods with the lifecycle state change they are interested in.\nFor example, the @OnLifecycleEvent(Lifecycle.Event.ON_START)annotation indicates that the method is watching the onStart lifecycle event.\n",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Flifecycle_library.png?alt=media&token=544d27ea-01dd-4704-a114-e57482a2c0fc",
    "menuId" : "02",
    "name" : "Lifecycle library"
  }, {
    "contentId" : "2003",
    "description" : "Parcelable and Bundle objects are intended to be used across process boundaries such as with IPC/Binder transactions, between activities with intents, and to store transient state across configuration changes. When an app creates an Intent object to use in startActivity(Intent) in starting a new Activity, the app can pass in parameters using the putExtra() method. In some cases, you may need a mechanism to send composite or complex objects across activities. In such cases, the custom class should implement Parcelable, and provide the appropriate writeToParcel(android.os.Parcel, int) method. It must also provide a non-null field called CREATOR that implements the Parcelable.Creator interface, whose createFromParcel() method is used for converting the Parcel back to the current object. ",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Fparcelables_and_bandles.png?alt=media&token=b0ceb757-cb7f-4676-90ea-a24da83c7f37",
    "menuId" : "02",
    "name" : "Parcelables and Bundles"
  }, {
    "contentId" : "2004",
    "description" : "A Fragment represents a behavior or a portion of user interface in a FragmentActivity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running (sort of like a \"sub activity\" that you can reuse in different activities). A fragment must always be hosted in an activity and the fragment's lifecycle is directly affected by the host activity's lifecycle. ",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Ffragment.png?alt=media&token=48a79791-9745-41d8-b243-1eff8055b0d4",
    "menuId" : "02",
    "name" : "Fragment"
  }, {
    "contentId" : "2005",
    "description" : "An intent allows you to start an activity in another app by describing a simple action you'd like to perform (such as \"view a map\" or \"take a picture\") in an Intent object. This type of intent is called an implicit intent because it does not specify the app component to start, but instead specifies an action and provides some data with which to perform the action. When you call startActivity() or startActivityForResult() and pass it an implicit intent, the system resolves the intent to an app that can handle the intent and starts its corresponding Activity. If there's more than one app that can handle the intent, the system presents the user with a dialog to pick which app to use.",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Fimplicit_intent.png?alt=media&token=ba464a6c-c69f-40dd-a80b-db8978836ead",
    "menuId" : "02",
    "name" : "Implicit intent"
  }, {
    "contentId" : "2006",
    "description" : "A dialog is a small window that prompts the user to make a decision or enter additional information. A dialog does not fill the screen and is normally used for modal events that require users to take an action before they can proceed. The Dialog class is the base class for dialogs, but you should avoid instantiating Dialog directly. Instead, use one of the following subclasses: AlertDialog A dialog that can show a title, up to three buttons, a list of selectable items, or a custom layout. DatePickerDialog or TimePickerDialog A dialog with a pre-defined UI that allows the user to select a date or time. These classes define the style and structure for your dialog, but you should use a DialogFragment as a container for your dialog. The DialogFragment class provides all the controls you need to create your dialog and manage its appearance, instead of calling methods on the Dialog object. Using DialogFragment to manage the dialog ensures that it correctly handles lifecycle events such as when the user presses the Back button or rotates the screen. The DialogFragment class also allows you to reuse the dialog's UI as an embeddable component in a larger UI, just like a traditional Fragment (such as when you want the dialog UI to appear differently on large and small screens).",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Fdialog_fragment.png?alt=media&token=89d47e77-b72f-471a-8703-7121d7c541d2",
    "menuId" : "02",
    "name" : "Dialog"
  }, {
    "contentId" : "2007",
    "description" : "Menus are a common user interface component in many types of applications. To provide a familiar and consistent user experience, you should use the Menu APIs to present user actions and other options in your activities.",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Fmenu.png?alt=media&token=625855c8-d7ac-46a9-b5f7-210b70e87254",
    "menuId" : "02",
    "name" : "Menu"
  }, {
    "contentId" : "2008",
    "description" : "Android apps can send or receive broadcast messages from the Android system and other Android apps. These broadcasts are sent when an event of interest occurs. For example, the Android system sends broadcasts when various system events occur, such as when the system boots up or the device starts charging. Apps can also send custom broadcasts, for example, to notify other apps of something that they might be interested in (for example, some new data has been downloaded).",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2Fbroadcast.png?alt=media&token=f29e649c-8a4e-455a-be9f-5a04b9885a0c",
    "menuId" : "02",
    "name" : "Broadcast"
  },
    {
    "contentId" : "2009",
    "description" : "If you have a relatively small collection of key-values that you'd like to save, you should use the SharedPreferences APIs. A SharedPreferences object points to a file containing key-value pairs and provides simple methods to read and write them. Each SharedPreferences file is managed by the framework and can be private or shared.",
    "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Android%2FsharedPrefernces.png?alt=media&token=0915a82d-51a3-4d59-b62a-0c1cd41e9e49",
    "menuId" : "02",
    "name" : "SharedPreferences "
  },
    {
      "contentId" : "3000",
      "description" : "Version control is a system that records\nchanges to a file or set of files over time so that you can recall specific versions later. Git thinks of its data more like a series of\nsnapshots of a miniature filesystem. With Git, every time you commit, or save the state of your\nproject, Git basically takes a picture of what all your files look like at that moment and stores a\nreference to that snapshot. To be efficient, if files have not changed, Git doesn’t store the file again,\njust a link to the previous identical file it has already stored. Git thinks about its data more like a\nstream of snapshots.\nGit has three main states that your files can reside in: modified,\nstaged, and committed:\n• Modified means that you have changed the file but have not committed it to your database yet.\n• Staged means that you have marked a modified file in its current version to go into your next\ncommit snapshot.\n• Committed means that the data is safely stored in your local database.\nThis leads us to the three main sections of a Git project: the working tree, the staging area, and the\nGit directory.\n",
      "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Additional%20tools%2Fgit.png?alt=media&token=19deaa31-d8fc-4993-bf9e-41bffcc42e12",
      "menuId" : "03",
      "name" : "Git"
    },
    {
      "contentId" : "3001",
      "description" : "A web service is a service on the internet that enables your app to make requests and get data back.\nCommon web services use a REST architecture. Web services that offer REST architecture are known as RESTful services. RESTful web services are built using standard web components and protocols.\nYou make a request to a REST web service in a standardized way, via URIs.\nTo use a web service, an app must establish a network connection and communicate with the service. Then the app must receive and parse response data into a format the app can use.\nThe Retrofit library is a client library that enables your app to make requests to a REST web service.\nUse converters to tell Retrofit what do with data it sends to the web service and gets back from the web service. For example, the ScalarsConverter converter treats the web service data as a String or other primitive. To enable your app to make connections to the internet, add the \"android.permission.INTERNET\" permission in the Android manifest. The response from a web service is often formatted in JSON, a common interchange format for representing structured data.A JSON object is a collection of key-value pairs. This collection is sometimes called a dictionary, a hash map, or an associative array. A collection of JSON objects is a JSON array. You get a JSON array as a response from a web service. The keys in a key-value pair are surrounded by quotes. The values can be numbers or strings. Strings are also surrounded by quotes. The Moshi library is Android JSON parser that converts a JSON string into Kotlin objects. Retrofit has a converter that works with Moshi.\nMoshi matches the keys in a JSON response with properties in a data object that have the same name.\nTo use a different property name for a key, annotate that property with the @Json annotation and the JSON key name.\n",
      "image" : "https://firebasestorage.googleapis.com/v0/b/mobiledevelopersummary-1a260.appspot.com/o/Additional%20tools%2Fretrofit_moshi_json.png?alt=media&token=9af42b82-2122-4d94-9826-00c2baa44731",
      "menuId" : "03",
      "name" : "WS_REST_Retrofit_Moshi_JSON"
    }
  ]
}
