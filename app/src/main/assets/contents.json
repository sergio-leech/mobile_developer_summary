{
  "contents": [
    {
      "contentId": 1,
      "menuId":"01",
      "name": "Basic Types",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 2,
      "menuId":"01",
      "name": "Packages and Imports",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 3,
      "menuId":"01",
      "name": "Classes and Inheritance",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 4,
      "menuId":"01",
      "name": "Enum Classes",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 5,
      "menuId":"01",
      "name": "Data Classes",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 6,
      "menuId":"02",
      "name": "Android",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 7,
      "menuId":"02",
      "name": "Android_2",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 8,
      "menuId":"02",
      "name": "Android_3",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 9,
      "menuId":"02",
      "name": "Android_4",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 10,
      "menuId":"02",
      "name": "Android_4",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 11,
      "menuId":"03",
      "name": "Git",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 12,
      "menuId":"03",
      "name": "Moshi",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 13,
      "menuId":"03",
      "name": "Timber",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 14,
      "menuId":"03",
      "name": "Retrofit2",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 15,
      "menuId":"03",
      "name": "Room Database",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    },
    {
      "contentId": 16,
      "menuId":"03",
      "name": "Dagger2",
      "image": "",
      "description": "Kotlin provides a set of built-in types that represent numbers. For integer numbers, there are four types with different sizes and, hence, value ranges. (Byte = 8 bits, Short = 16 bits, Int=32 bits, Long = 64 bits)\nAll variables initialized with integer values not exceeding the maximum value of Int have the inferred type Int. If the initial value exceeds this value, then the type is Long. To specify the Long value explicitly, append the suffix L to the value.\nFor floating-point numbers, Kotlin provides types Float and Double. For variables initialized with fractional numbers, the compiler infers the Double type. To explicitly specify the Float type for a value, add the suffix f or F.\nYou can use underscores to make number constants more readable: val oneMillion = 1_000_000.\nEvery number type supports the following conversions: toByte(): Byte, toShort(): Short, toInt(): Int, toLong(): Long, toFloat(): Float, toDouble(): Double, toChar(): Char.\nKotlin supports the standard set of arithmetical operations over numbers (+ - * / %).\nAs for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form.  shl(bits) – signed shift left, shr(bits) – signed shift right, ushr(bits)  unsigned shift right, and(bits) – bitwise and, or(bits) – bitwise or, xor(bits) – bitwise xor, inv() – bitwise inversion\nThe operations on floating point numbers discussed in this section are: Equality checks: a == b and a != b, Comparison operators: a < b, a > b, a <= b, a >= b, Range instantiation and range checks: a..b, x in a..b, x !in a..b.\n"
    }

  ]
}